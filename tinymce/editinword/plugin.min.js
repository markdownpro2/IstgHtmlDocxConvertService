// TinyMCE Plugin: Edit in Word Plugin for working with word

const ERRORS = {
  1001: {
    fa: "editinword_generate_url باید تعریف شود",
    en: "editinword_generate_url must be defined",
  },
  1002: {
    fa: "editinword_websocket_url باید تعریف شود",
    en: "editinword_websocket_url must be defined",
  },
  1003: {
    fa: "editinword_token باید تعریف شود",
    en: "editinword_token must be defined",
  },
  2001: {
    fa: "تولید لینک فایل وورد با خطا مواجه شد",
    en: "Failed to generate Word file link",
  },
  2002: {
    fa: "خطا در برقراری ارتباط با سرور ویرایش وورد",
    en: "Failed to communicate with the Word editing server",
  },
  2003: {
    fa: "خطا در ارتباط زنده با وورد",
    en: "Live connection with Word failed",
  },
  2004: {
    fa: "ایجاد نشست جدید مجاز نمی باشد",
    en: "Generating new session is not allowed",
  },
  2005: {
    fa: "فایل وورد در بازه مجاز توسط کاربر باز نشد",
    en: "Word file did not open in time",
  },
  3001: {
    fa: "محتوا با موفقیت از وورد بروزرسانی شد",
    en: "Content successfully updated from Word",
  },
  3002: {
    fa: "نشست از سمت وورد پایان یافت",
    en: "Session ended from the Word side",
  },
  3003: {
    fa: "ویرایش در وورد غیر فعال شد",
    en: "Edit in Word was deactivated",
  },
  4001: {
    fa: "خطا در برقراری ارتباط با سرور",
    en: "Failed to communicate with server",
  },
  4002: {
    fa: "نشست از سمت وورد پایان یافت",
    en: "Session ended from Word",
  },
  4003: {
    fa: "پیام وب‌سوکت نامعتبر یا غیرمنتظره",
    en: "Unexpected or failed WebSocket message",
  },
  4004: {
    fa: "تجزیه پیام وبسوکت با خطا مواجه شد",
    en: "Failed to parse WebSocket message",
  },
  4005: {
    fa: "خطا در WebSocket",
    en: "WebSocket error",
  },
  4006: {
    fa: "نشست از سمت سرور منقضی شد",
    en: "Session expired from server",
  },
};

tinymce.PluginManager.add("editinword", function (editor) {
  // Get plugin parameters from TinyMCE init
  const editinword_generate_url = editor.getParam("editinword_generate_url");
  const editinword_websocket_url = editor.getParam("editinword_websocket_url");
  const Token = editor.getParam("editinword_token");

  const actions = {
    getHtml: "get-html",
    endSession: "end-session",
    sessionClosed: "session-closed",
  };
  const sessionStorageKey = "open_in_word_session";
  // Validate required parameters
  if (!editinword_generate_url) {
    showMessage(1001);
    return;
  }
  if (!editinword_websocket_url) {
    showMessage(1002);
    return;
  }
  if (!Token) {
    showMessage(1003);
    return;
  }

  // State variables
  // The reason I made editInWordPluginState a global variable is because of
  // the auto save mechanism makes a full page reload which interrupts the connection between client and server
  window.editInWordPluginStatus = false;
  let socket = null;
  let sessionId = null;

  // Add the toggle button to the TinyMCE toolbar
  editor.ui.registry.addToggleButton("editinword", {
    tooltip: "Edit in Word",
    icon: "editinword",
    onAction: async (api) => {
      window.editInWordPluginStatus = !window.editInWordPluginStatus;
      api.setActive(window.editInWordPluginStatus);

      if (!window.editInWordPluginStatus) {
        // Deactivate: Make editor editable again and end session
        editor.getBody().setAttribute("contenteditable", "true");
        sessionId = sessionStorage.getItem(sessionStorageKey);

        if (socket && socket.readyState === WebSocket.OPEN) {
          // Notify server to end session
          socket.send(
            JSON.stringify({
              Origin: "client",
              SessionId: sessionId,
              Action: actions.endSession,
              Success: true,
            })
          );
          socket.close();
        }
        sessionStorage.removeItem(sessionStorageKey);
        return;
      } else {
        // Activate: Make editor read-only
        makeContentReadOnly();
      }

      // Prepare HTML content to send to server
      const content = editor.getContent();
      const html = `
        <html>
          <head><meta charset="utf-8"></head>
          <body>
            <div class="tinymce-content" dir="rtl">
              ${content}
            </div>
          </body>
        </html>`;

      sessionId = sessionStorage.getItem(sessionStorageKey);

      editor.notificationManager.open({
        text: "در حال تولید لینک فایل وورد لطفا منتظر باشید",
        type: "info",
        timeout: 3000,
      });

      // Send content to server to generate Word document and get session info
      try {
        const res = await fetch(editinword_generate_url, {
          method: "POST",
          headers: { "Content-Type": "application/json", Token },
          body: JSON.stringify({ Html: html }),
        });

        const response = await res.json();
        if (!res.ok) {
          if (response.errorCode === "H1006") showMessage(2004);
          else if (response?.message == "") showMessage(2001);
          console.error(`editinword: ${res.status} - ${response?.message}`);
          deactivate(api);
          return;
        }

        // Store session ID if provided
        if (response.sessionId) {
          sessionId = response.sessionId;
          sessionStorage.setItem(sessionStorageKey, sessionId);
        }

        // Redirect to Word URL if provided
        // if (response.wordUrl) {
        //   window.location.href = response.wordUrl;
        // }

        // Redirect to Word URL if provided
        if (response.wordUrl) {
          const win = window.open(response.wordUrl, "_blank");

          if (!win || win.closed || typeof win.closed === "undefined") {
            // Popup blocked or failed to open
            console.warn("Word URL window failed to open");
            showMessage(2001); // Custom failure message
            return;
          }

          // Wait up to X seconds for the window to auto-close
          const maxWaitMs = 8000; // Adjust based on expected Word launch time
          const pollInterval = 500;
          let waited = 0;

          const pollTimer = setInterval(() => {
            if (win.closed) {
              clearInterval(pollTimer);
              console.info("✅ Word editing window closed successfully.");
              // You can optionally show success or continue with WebSocket
            } else if (waited >= maxWaitMs) {
              clearInterval(pollTimer);
              console.warn(
                "❌ Word window did not close in time — assuming failure."
              );
              showMessage(2005); // or a more specific message
              win.close(); // Close manually if needed

              if (socket && socket.readyState === WebSocket.OPEN) {
                // Notify server to end session
                socket.send(
                  JSON.stringify({
                    Origin: "client",
                    SessionId: sessionId,
                    Action: actions.endSession,
                    Success: true,
                  })
                );
                socket.close();
              }

              deactivate(api);
            }

            waited += pollInterval;
          }, pollInterval);
        }

        // Connect to WebSocket for live updates
        connectWebSocket(sessionId, api);
      } catch (err) {
        console.error("editinword: Failed to communicate with server", err);
        showMessage(2002);
        deactivate(api);
      }
    },
  });

  // WebSocket connection for live HTML updates from Word
  function connectWebSocket(sessionId, api) {
    socket = new WebSocket(editinword_websocket_url);

    socket.onopen = () => {
      // Request HTML update immediately on connect
      sendGetHtml();
    };

    socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);

        if (
          message.Action === actions.getHtml &&
          message.Success &&
          message.SessionId === sessionId
        ) {
          // Update editor content with new HTML from Word
          editor.setContent(message.Content);
          editor.fire("change");
          // showMessage(3001, "info");
        } else if (
          message.Action === actions.endSession &&
          message.Success &&
          message.SessionId
        ) {
          // Session ended from Word side
          console.warn("Session ended from Word");
          showMessage(3002, "info");
          socket?.close();
          deactivate(api);
        } else if (
          message.Action === actions.sessionClosed &&
          message.Success
        ) {
          console.warn("Session closed");
          showMessage(4006, "warning");
          socket?.close();
          deactivate(api);
        } else {
          // Unexpected message, close connection and deactivate
          showMessage(4003, "warning");
          socket?.close();
          deactivate(api);
        }
      } catch (err) {
        showMessage(4004, "error");
        console.error("Failed to parse WebSocket message:", err);
      }
    };

    socket.onerror = (err) => {
      console.error("WebSocket error:", err);
      showMessage(2003);
    };

    socket.onclose = () => {
      deactivate(api);
    };
  }

  function makeContentEditable() {
    editor.getBody().setAttribute("contenteditable", "true");
  }

  function makeContentReadOnly() {
    editor.getBody().setAttribute("contenteditable", "false");
  }

  // Helper: Deactivate plugin and clean up
  function deactivate(api) {
    // showMessage(3003, "info");
    window.editInWordPluginStatus = false;
    api.setActive(window.editInWordPluginStatus);
    makeContentEditable();
    sessionStorage.removeItem(sessionStorageKey);
  }

  // Helper: Send request for latest HTML from server
  function sendGetHtml() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(
        JSON.stringify({
          Origin: "client",
          Token,
          SessionId: sessionId,
          Action: actions.getHtml,
        })
      );
    }
  }

  function showMessage(code, type = "error", lang = "fa") {
    const message = ERRORS[code]?.[lang] || "خطای ناشناخته";
    editor.notificationManager.open({
      text: message,
      type: type,
      timeout: 3000,
    });

    console.error(`editinword: ${message}`);
  }
});
